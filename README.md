# Домашнее задание к лекции 5 «Классы»

## Решения
### Задание 1
 * <a href="https://github.com/Nephedov/bjs-2-homeworks/blob/bjs-53/5.classes/task.js">task.js</a> - код с реализованными функциями.

<a href="https://github.com/Nephedov/bjs-2-homeworks/tree/bjs-53/5.classes">Репозиторий</a> с заданием и тестами.
Запуск через:
* <a href="https://github.com/Nephedov/bjs-2-homeworks/blob/bjs-53/5.classes/index.html">index.html</a>,
* <a href="https://github.com/Nephedov/bjs-2-homeworks/blob/bjs-53/5.classes/student_tests.html">student_tests.html</a>.

## Что было сделано
* Создан родительский класс PrintEditionItem, описывающий свойства печатного издания и имеющий метод "починки" (увеличение значения одного из свойств), при вызове у экземпляра класса.
* Созданы дочерние классы Magazine, Book, NovelBook, FantasticBook, FantasticBook, от класса PrintEditionItem.
* Создан класс Library, описывающий методы взаимодействия с экземплярами класса PrintEditionItem (добавление в список, поиск, удаление из списка).
* Создан класс Student, с методами добавления и получения значений (оценок) экземпляра Student.
* Решение задания опубликовано в Github Pages.

## Описание Задания 1. Печатное издание

Задача продолжает идеи, заложенные в предыдущем ДЗ, но уже с использованием всех возможностей классов. 

Нужно помочь перевести небольшую районную библиотеку в современный цифровой формат. Начнём с реализации нескольких классов: 

- классы печатных изданий — книг, журналов;
- класс библиотеки, который позволит работать с печатными изданиями: хранить их, выдавать читателям, принимать обратно.

### Что нужно сделать

Печатные издания бывают разных видов, но между всеми книгами, сборниками и журналами есть много общего: у всех них есть название, год издания, страницы, они могут повреждаться с процессе использования.

1. Создайте базовый класс `PrintEditionItem` со свойствами:

   - `name`;
   - `releaseDate`;
   - `pagesCount`;
   - `state`;
   - `type`.

 Конструктор класса должен принимать название (`name`), дату выпуска (`releaseDate`) и количество страниц (`pagesCount`) в качестве аргумента. Состояние (`state`) по умолчанию должно быть `100`, тип `type` пока должен быть равен `null`.

2. Испорченное издание можно подклеить и улучшить его состояние. Создайте метод `fix()`, увеличивающий `state` в полтора раза. Метод не должен принимать аргументы.

3. Нельзя улучшить новое издание, также бесполезно подклеивать полностью уничтоженное. Чтобы лучше контролировать состояние книг, создайте «сеттер» для свойства `state`, принимающий в качестве аргумента новое состояние печатного издания (число).

   Если новое состояние меньше `0`, «сеттер» должен записать в свойство `state` значение `0`. Если новое состояние больше `100`, должно быть записано значение `100`. В остальных случаях в свойство `state` должно быть записано переданное в «сеттер» значение.

4. Создайте «геттер», который позволит читать значение свойства `state`.

5. Создайте класс `Magazine`, который будет наследоваться от класса `PrintEditionItem`. Конструктор класса должен принимать такие же параметры, как и класс-родитель. От базового печатного издания журнал отличается только указанным типом. Значение свойства `type` должно быть равно `"magazine"`.

6. Создайте класс `Book`, который наследуется от класса `PrintEditionItem`. Конструктор класса должен принимать такие же параметры, как и класс-родитель, и имя автора книги `author`. Значение свойства `type` должно быть равно `"book"`.

7. Создайте классы, которые наследуются от класса `Book`: `NovelBook` — для романов, `FantasticBook` — для фантастических произведений и `DetectiveBook` — для детективов. Значения свойства `type` должны быть равны `"novel"`, `"fantastic"` и `"detective"` соответственно.

## Описание Задания 2. Библиотека

Теперь с помощью классов можно описать все возможные печатные издания, которые бывают в библиотеке. Пришло время подготовить саму библиотеку к работе в цифровом режиме — реализовать возможность хранить книги, выдавать их читателям и принимать обратно.

### Что нужно сделать

1. Создайте класс `Library` со свойствами:

   - `name`;
   - `books`.

   Конструктор класса должен принимать название библиотеки `name` (строка). Значением свойства `books` должен быть пустой массив.

2. Реализуйте метод `addBook(book)`, который в качестве аргумента будет принимать объект — книгу или журнал. Метод должен добавлять книгу в хранилище `books`, только если состояние `state` книги больше `30`.

3. Создайте метод `findBookBy(type, value)`, который в качестве аргументов будет принимать ключ для проведения поиска (тип, автор, название, год выпуска и пр.) и искомое значение. Метод должен возвращать книгу в случае успеха и `null`, если запрошенная книга не была найдена.

4. Создайте метод `giveBookByName(bookName)`, который в качестве аргумента будет принимать название книги, запрошенной читателем. Если запрошенная книга найдена, метод должен удалять книгу из хранилища `books` и возвращать её. Если книга не была найдена, метод должен возвращать `null`.

5. Протестируйте корректность работы классов и методов, реализовав тестовый сценарий:
   - создайте библиотеку;
   - добавьте в библиотеку несколько печатных изданий разных типов;
   - найдите книгу, изданную в 1919 году, или создайте её при необходимости;
   - выдайте любую книгу;
   - повредите выданную книгу;
   - восстановите выданную книгу;
   - попытайтесь добавить восстановленную книгу обратно в библиотеку.
  
  ## Описание Задания 3. Журнал успеваемости *

Мы продолжаем совершенствовать журнал успеваемости студентов. Нужно преобразовать код прошлого ДЗ к классам. Реализуйте возможности:

1. В конструкторе класса сохраняйте имя пользователя и создавайте свойство для хранения оценок.
2. Метод `addMark`, который будет добавлять оценку по предмету.

 * Валидируйте оценку. Она должна быть не меньше 2 и не больше 5. Если значение выходит за пределы этого диапазона, оценка не должна добавиться, и метод следует завершать.
 * Проверьте наличие предмета. Если предмет отсутствует в свойстве `marks`, то добавляйте новое свойство, названием которого будет название предмета, а значением — пустой массив.
  * Добавляйте в массив оценок по переданному свойству новый элемент, который был получен аргументом метода.
3. Метод `getAverageBySubject`, который будет возвращать среднюю оценку по одному предмету.
    * Проверьте наличие предмета среди оценок. Если предмет отсутствует, сразу возвращайте ноль.
    * С помощью `reduce` посчитайте сумму оценок по одному предмету.
    * Возвращайте результат деления суммы оценок на их количество.
4. Метод `getAverage`, который будет возвращать общую среднюю оценку по всем предметам.
    * Используйте метод `Object.keys` для получения всех названий предметов.
    * С помощью метода `reduce` или использования цикла перебирайте все предметы. Для каждого считайте среднюю оценку с помощью метода `getAverageBySubject` и суммируйте полученные значения.
    * Возвращайте результат деления суммы средних оценок на количество предметов.

Для решения задания нужно придумать структуру данных для хранения оценок по предметам. Это представляет наибольшую сложность.
